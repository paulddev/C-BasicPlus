# 클래스와 동적 메모리 대입
- 클래스 멤버를 위한 동적 메모리 대입
- 암시적/명시적 오버로딩 대입 연산자
- static 클래스 멤버
- 객체를 지시하는 포인터
- 암시적/명시적 복사 생성자
- 생성자에 new 사용하기
- 객체에 위치 지정 new 사용하기
- 큐 ADT 구현!!!

기억 공간을 얼마나 사용하느냐와 같은 중요한 문제들을, 프로그램을 컴파일할 때가 아니라
실행할 때 결정하도록 만드는 것이 훨씬 좋다.

프로그램을 실행할 때 그 이름에 꼭 맞는 크기의 메모리를 대입하는 것이다.

12.1 동적 메모리와 클래스
메모리를 동적으로 제어하기 위해서는 C++에서 new와 delete 연산자를 사용한다.

# 디폴트 생성자
사용자가 어떠한 생성자도 제공하지 않으면, C++은 디폴트 생성자를 제공한다.
Klusk::Klusk() {}

매개변수도 사용하지 않고 아무런 일도 하지 않는 생성자
단지 객체를 만들면 항상 생성자가 호출되기 때문에 필요한 것.

사용자가 어떤 생성자를 정의했다면, C++는 디폴트 생성자를 제공하지 않는다.
명시적으로 초기화하지 않는 객체를 만들고 싶거나, 객체들의 배열을 만들고 싶다면?
디폴트 생성자를 정의해야 한다.

디폴트 생성자는 매개변수를 사용하지 않는 생성자다.
그러나 특별한 값들을 설정하는 데 사용될 수 있다.
-> 매개변수를 사용하는 생성자들도, 모든 매개변수들에 디폴트 값을 제공한다면, 디폴트 생성자가 될 수 있다.

Klusk() { klunk_ct = 0; } // 생성자 #1
Klusk(int n = 0) { klunk_ct = n; } // 모호한 생성자 #2

Klusk kar(10); // Klusk(int n)에 명백하게 부합됨
Klusk bus;     // 두 생성자에 모두 부합됨...
-> 디폴트 생성자는 하나만! 가질 수 있다.

# 복사 생성자
어떤 객체를 새로 생성되는 객체에 복사하는 데 사용된다.
일반적인 대입에 사용되는 것이 아니라 값 전달에 의한 함수 매개변수 전달을 포함한 초기화 작업에 사용된다.

Class_name(const Class_name&);
클래스 객체에 대한 const 참조를 매개변수로 사용한다.

*복사 생성자는 언제 사용되는가?
새로운 객체가 생성되어 같은 종류의 기존의 객체로 초기화될 때마다 호출된다.
새로운 객체를 기존의 객체로 명시적으로 초기화할 때

StringBad ditto(motto);  // StringBad(const StringBad&)를 호출한다.
StringBad metoo = motto; // StringBad(const StringBad&)를 호출한다.
StringBad also = StringBad(motto); // StringBad(const StringBad&)을 호출한다.
StringBad * pStringBad = new StringBad(motto); // StringBad(const StringBad&);

객체를 값으로 전달할 때, 객체를 리턴할 때 모든 컴파일러는 복사 생성자를 호출한다.

객체를 값으로 전달하면 복사 생성자가 호출되기 때문에, 참조로 전달하는 것이 더 좋다.
참조로 전달하면? 생성자를 호출하는 시간과, 새로운 객체를 저장하는 메모리 공간이 절약되기 때문이다.

*복사 생성자는 무슨 일을 하는가?
디폴트 복사 생성자는 static 멤버를 제외한 멤버들을 멤버별로 복사한다.(멤버별 복사 또는 얕은 복사라고도 함)
각 멤버는 값으로 복사된다.
StringBad sailor = sports;

멤버 자체가 클래스 객체라면? 그 클래스의 복사 생성자는 그 멤버 객체를 다른 객체에 복사한다.
num_strings와 같은 static 멤버는 개별적인 객체들에 속하는 것이 아니라
그 클래스 전체에 속하기 때문에 영향을 받지 않는다.

객체의 생성 내력과 상관 없이, 파괴자는 항상 호출되기 때문에
보통 복사 생성자에서 포인터를 복사하므로, 파괴자에서 한 번 해제된 메모리 위치를 다시 delete 하려고 할 때??
무슨 일을 저지를지 알 수 없다.

-> 명시적 복사 생성자로 이 문제를 해결
클래스 설계상의 문제점을 해결하는 방법은 깊은 복사(deep copy)를 하게 만드는 것이다.
복사 생성자가 문자열의 주소만 달랑 복사하지 말고, 문자열 자체를 복사하고, 그 복사본의 주소를 str 멤버에 대입하게 만드는 것이다.
이렇게 한다면
각 객체는 다른 객체의 문자열을 참조하지 않고, 자기 몫의 문자열을 따로 갖게 된다.
이제 각각의 파괴자 호출은 동일한 하나의 문자열을 해제하려는 중복된 시도를 하지 않고 서로 다른 문자열을 해제하게 된다.

복사 생성자를 필수적으로 정의해야 하는 이유는?
일부 클래스 멤버들이 데이터 자체가 아니라, new에 의해 초기화되는 데이터를 지시하는 포인터들이기 때문이다.

# StringBad 문제점: 대입 연산자
어떤 클래스에 대해 대입 연산자를 자동으로 오버로딩함으로써 그것을 허용하는데
Class_name& Class_name::operator=(const Class_name&);
클래스 객체에 대한 참조를 매개변수로 하고, 또 그것을 리턴한다.

대입 연산자는 언제 사용되고 무슨 일을 하는가?
오버로딩 대입 연산자는 하나의 객체를 기존의 다른 객체에 대입할 때 사용된다.
StringBad headline1("Celery Stalks");
StringBad knot;
knot = headline1; // 오버로딩 대입 연산자를 호출한다.

대입 연산자는 객체를 초기화할 때 반드시 사용되는 것은 아니다.
StringBad metoo = knot; // 복사 생성자를 사용한다. 대입도 가능하다.

여기서 metoo는 knot의 값으로 초기화되면서 새로 생성되는 객체다. -> 복사 생성자가 사용된다.
어떤 C++ 시스템은 이 구문을 2단계로 처리하기도 한다.
- 복사 생성자를 사용하여 임시 객체를 먼저 생성
- 대입을 사용하여 그 값들을 그 새로운 객체에 복사.
초기화는 복사 생성자를 항상 호출한다. 또한 =연산자를 사용하는 형식들은 대입 연산자를 호출할 수도 있다.

복사 생성자와 마찬가지로, 대입 연산자의 암시적 구현은 멤버별 복사를 수행한다.
멤버 자체가 어떤 클래스의 객체라면? 프로그램은 그 클래스에 대해 정의된 대입 연산자를 사용하여 그 특별한 멤버를 복사한다.
static 데이터 멤버들은 영향을 받지 않는다.

대입이 잘못된 부분
knot = headline1;

암시적 복사 생성자가 일으키는 것과 동일한 문제인 데이터 파손
멤버별 복사가 headline1.str와 knot.str가 동일한 주소를 지시하도록 만들었기 때문
knot를 파괴하기 위해 파괴자가 호출되었을 때, 문자열을 삭제하는데
그 후 headline1을 파괴하기 위해 파괴자가 호출되었을 때, 그것은 이미 삭제된 문자열을 다시 삭제하려고 시도한다.

삭제한 데이터를 다시 삭제하려고 시도하는 것은 어떻게 될지 그 결과를 알 수 없다.
메모리의 내용이 엉뚱한 것으로 바뀔 수도 있고, 프로그램이 먹통이 될 수도 있다.

# 대입에서 발생하는 문제의 해결책
깊은 복사를 하는 대입 연산자 정의를 사용자가 직접 제공하는 것이다.
복사 생성자와 비슷하지만, 몇 가지 차이가 있다.

- 타깃 객체가 이전에 대입된 데이터를 참조하고 있을 수도 있으므로, 그 함수는 delete[]를 사용하여 이전의 의무를 해제해 주어야 한다.
- 그 함수는 어떤 객체를 자기 자신에게 대입하지 못하게 막아야 한다. 막지 않으면, 메모리의 해제가 내용을 다시 대입하기도 전에 그 객체의 내용을 먼저 지울 수 있으므로.
- 그 함수는 호출한 객체에 대한 참조를 리턴한다.

객체를 리턴함으로써, 내장 데이터형들에 대해 보통의 대입을 사슬처럼 연결하는 것을 똑같이 에뮬레이트 할 수 있다.
s0 = s1 = s2; // s0, s1, s2가 StringBad 객체일 때
s0.operator=(s1.operator(s2));

StringBad& StringBad::operator=(const StringBad& st)
{
	if (this == &st)  // 객체가 자기 자신에 대입되었다면 끝내자. -> 메모리의 해제로 인해 내용을 다시 대입하기도 전에 그 객체의 내용을 지워버리기 때문
		return *this;

	delete[] str;              // 옛 문자열을 해제한다.
	len = st.len;              
	str = new char[len + 1];   // 새 문자열을 위한 공간을 확보
	str::strcpy(str, st.str);  // 문자열을 복사
	return *this;              // 호출한 객체에 대한 참조를 리턴
}

옛 문자열을 해제하는 이유는
프로그램은 더 이상 옛 문자열을 지시하는 포인터를 가지고 있지 않으므로, 그 메모리는 낭비가 될 것이기 때문

대입은 새로운 객체를 만들지 않는다.
그래서 static 데이터 멤버인 num_strings의 값을 조정할 필요는 없다. (복사 생성자와는 다르게)

복사 생성자와 대입 연산자를 StringBad 클래스에 추가하면? 모든 문제가 해결된다!

12.3 생성자에 new를 사용할 때 주의할 사항들
- 생성자에서 new를 사용하여 포인터 멤버를 초기화했다면, 파괴자에 반드시 delete 사용하기
- new와 delete의 사용은 서로 어울려야 한다. 서로 짝을 이루어야 하고, new[]는 delete[]와 짝을 이뤄야 한다.
- 생성자가 여러 개일 경우에는, 모두 대괄호를 사용하든지 아니면 모두 대괄호 없이 사용하든지, 모든 생성자가 같은 방법으로 new를 사용해야 한다. 
  파괴자는 하나밖에 없으므로, 모든 생성자가 파괴자와 어울려야 하기 때문,
  다만 하나의 생성자에서 new를 사용하여 포인터를 초기화하고, 다른 생성자에서 널 포인터(NULL or 0)로 초기화하는 것은 허용한다.
  대괄호가 있든 없든 간에 delete 연산자를 널 포인터에 적용할 수 있기 때문이다!!


# NULL, 0, nullptr
널 포인터는 0 또는 NULL로 나타낼 수 있다.
NULL은 여러 개의 헤더 파일에 0으로 정의되어 있는 기호 상수다.
C 프로그래머들은 흔히 포인터의 값이라는 사실을 잊지 않기 위해서 0 대신 NULL을 사용하였다.
널 문자를 나타낼 때에도 0 대신 '\0'을 사용한다.

C++ 프로그래머들은 더 간단한 표기를 좋아한다.
0 혹은 C++11에서는 nullptr 키워드를 대안으로 제시하고 있다.

# 깊은 복사
깊은 복사를 통해 하나의 객체를 다른 객체로 초기화하는, 복사 생성자에서는
데이터의 주소가 아니라 데이터 그 자체를 복사해야 한다는 것을 명심하자.
또한, 그 과정에서 값이 영향을 받을 수 있는 모든 static 클래스 멤버들을 갱신하자.

깊은 복사를 통해 하나의 객체를 다른 객체에 대입하는, 대입 연산자를 정의해야 하는데
String& String::operator=(const String& st)
{
	if (this == &st)
		return *this;

	delete[] str;
	len = st.len;
	str = new char[len + 1];
	std::strcpy(str, st.str);
	return *this;
}

중요한 점은 자기 자신에 대입하는지 꼭 검사하자.

12.4 객체 리턴에 대한 관찰!!
- 객체의 대한 참조
- 객체애 대한 const 참조
- 객체
- const 객체

# const 객체에 대한 참조
const 참조를 사용하는 주된 이유는 효율성이다.
다만 이것을 사용할 수 있는 상황은 제한적이다.
어떤 함수가 객체 호출 방식으로 또는 메서드 매개변수로 자신에게 전달된 객체를 리턴한다면? 참조를 리턴함으로써 그 메서드의 효율성을 높힌다.

const Vector& Max(const Vector& v1, const Vector& v2)
{
	if (v1.magval() > vw.magval())
		return v1;
	else
		return v2;
}

객체를 리턴하는 것은 복사 생성자를 호출하지만,,, 참조를 리턴하는 것은 그렇지 않다.

# const가 아닌 객체에 대한 참조 리턴
cout과 함께 사용하기 위한 대입 연산자의 오버로딩, << 연산자의 오버로딩이 대표적인 예시다.
이거는 필요성 때문에 const가 아닌 객체에 대한 참조를 리턴해야 한다.

operator=()의 리턴값은 연쇄적인 대입에 사용된다.
s3 = s2 = s1;

operator<<()의 리턴값은 연쇄적인 출력에 사용된다.
cout << s1 << "is coming!";

ostream&이 되어야 연쇄적으로 사용이 가능하기 때문,
만약에 ostream 리턴형을 사용한다면, ostream 복사 생성자의 호출을 요구하게 될 것이다.

다만, ostream 클래스는 public 복사 생성자를 만들지 않는다.
cout에 대한 참조를 리턴하는 것은, 호출하난 함수의 사용 범위 안에 이미 cout이 들어 있기 때문이다.

# 객체 리턴
리턴되는 객체가 피호출 함수에 지역적이면? 함수가 종료될 때 그 지역적인 객체가 파괴자를 호출하기 때문에
참조로 리턴하면 안된다.
호출하는 함수로 제어가 복귀할 때, 그 참조가 참조할 수 있는 객체가 더 이상 남아 있지 않기 때문이다.

이러한 경우에는 보통 참조가 아니라 객체를 리턴해야 한다.
대표적으로는 오버로딩 산술 연산자들이 이 범주에 속한다.

Vector force1(50, 60);
Vector force2(10, 70);
Vector net;
net = force1 + force2;

이 과정에서 force1, force2는 변경되면 안 되기 때문에, force1, force2 리턴값은 아니다.
호출하는 함수에 이미 존재하는 객체에 대한 참조는 리턴값이 될 수 없다.
그 대신에, 그 합은 Vector::operator+()에서 계산되는 새로운 임시 객체가 되는데
그 함수도 역시 임시 객체에 대한 참조를 리턴하면 안 된다.
그 대신에, 참조가 아니라 실제 vector 객체를 리턴해야 한다!
Vector Vector::operator+(const Vector& b) const
{
	return Vector(x + b.x, y + b.y);
}

리턴되는 객체를 만들기 위해 복사 생성자를 호출하는 가외의 일이 필요하다.
하지만 이것을 피할 수 없다.

# const 객체 리턴
net = force1 + force2; // 3개의 Vector 객체(1)
force1 + force2 = net; // 난독 프로그래밍(2)
cout << (force1 + force2 = net).magval() << endl; // 미친 프로그래밍(3)

프로그래머도 사람이기 때문에 실수를 한다.

해당 프로그램은 force1과 force2의 합을 계산하고, 그 결과를 임시 리턴 객체에 복사한다.
그 내용을 net의 내용으로 덮어쓰고, 그 임시 객체를 파괴한다. (이때 원래 벡터들은 변경되지 않는다.)
-> 임시 객체의 크기는 객체가 삭제되기 전에 디스플레이된다.

리턴형을 const 객체로 선언하게 되면
구문 1은 허용하지만, 2와 3은 허용되지 않는다.

<요약>
메서드나 함수가 지역 객체를 리턴한다면, 참조가 아니라 객체를 리턴하자.
메서드나 함수가 ostream 클래스와 같이 public 복사 생성자가 없는 클래스의 객체를 리턴한다면 객체에 대한 참조를 리턴하자.
오버로딩 대입 연산자와 같은 일부 메서드와 함수들은 객체 또는 객체에 대한 참조 어느 것이나 리턴할 수 있다.
효율성 때문이라면 참조를 사용하자.


메서드나 함수가 지역 객체를 리턴하면, 참조가 아니라 객체를 리턴해야 한다.

12.5 객체를 지시하는 포인터
C++프로그램은 객체를 지시하는 포인터를 자주 사용하게 된다.

각 책체가 생성될 때마다 new를 사용하여 이름 문자열을 저장하기 위한 메모리 공간을 대입하는데
이 일들은 생성자 함수에서 일어난다.
그래서 파괴자 함수는 delete를 사용하여 그 메모리를 해제해야 한다.

또 각 문자열은 문자들의 배열이므로, 그 파괴자는 delete를 사용한다.

문자열의 내용을 저장하기 위해 대입된 메모리는 그 객체가 파괴될 때, 자동으로 해제된다. (파괴자가 해줌)

String* favorite = new String(sayings[choice]);
이것은 문자열을 저장하기 위한 것이 아니라 객체를 저장하기 위한 메모리 공간을 대입한 것이다.
프로그램은 객체의 사용을 마친 후 delete를 사용하여 이 객체를 삭제해야 한다.
이 객체는 단일 객체이므로 대괄호 없는 delete를 사용한다.

*여러 케이스들
- 객체가 자동 변수이면 그 객체의 파괴자는 프로그램이 그 객체가 정의된 블록을 벗어날 때 호출된다.
- 객체가 static 변수이면, 그 객체의 파괴자는 프로그램이 종료될 때 호출된다.
- new에 의해 생성된 객체라면, 그 객체의 파괴자는 그 객체에 대해 명시적으로 delete를 사용할 때 호출된다.

# 포인터와 객체에 대한 요약
객체를 지시하는 포인터를 사용할 때

- 객체를 지시하는 포인터는 일반적인 포인터 형식을 사용하여 선언한다.
String* glamour;
- 기존의 객체를 지시하도록 포인터를 초기화할 수 있다.
String* first = &sayings[0];
- new를 사용하여 포인터를 초기화할 수 있다. 이것은 새 객체를 생성한다.
String* favorite = new String(sayings[choice]);

- new를 클래스와 함께 사용하면, 새로 생성되는 객체를 초기화하기 위해 적절한 클래스 생성자가 호출된다.
String* gleep = new String; // 디폴트 생성자가 호출
String* glop = new String("My my"); // String(const char*) 생성자를 호출
String* favorite = new String(sayings[choice]); // String(const String&) 생성자를 호출한다.

- 포인터를 사용하여 클래스 메서드에 접근하려면 -> 연산자를 사용한다.
if (sayings[i].length() < shortest->length())

- 객체를 얻기 위해서는 객체를 지시하는 포인터에 내용 참조 연산자(*)를 적용한다.
if (sayings[i] < *first) // 객체 값들을 비교한다.
	first = &sayings[i]; // 객체 주소를 대입한다.

# new를 사용하여 객체 생성하기
String *pveg = new String("Cabbage");

1. 객체를 저장하기 위한 메모리를 대입한다.
2. 다음과 같은 일을 처리하는 클래스 생성자를 호출한다.
- "Cabbage"을 위한 공간을 대입한다.
- 대입된 공간에 "Cabbage"를 복사한다.
- "Cabbage" 문자열의 주소에 str에 대입한다.
- 값 19를 len에 대입한다.
- num_strings를 갱신한다.
3. pveg 변수를 생성한다.
4. 새로운 객체의 주소를 pveg 변수에 대입한다.

# 위치 지정 new는 메모리를 대입하는 데 사용할 메모리 위치를 사용자가 직접 지정하는 것을 허용한다는 것을 기억하자.

중요한 점은 올바른 삭제 순서다.
위치 지정 new가 생성한 객체들은 생성된 순서의 역순으로 파괴되어야 한다.
위치 지정 new가 생성한 객체들은 먼저 생성된 객체에 의존할 수도 있기 때문에, 객체를 저장하는 데 사용되는 버퍼는
그 버퍼에 들어 있는 모든 객체가 파괴된 후에 해제되어야 한다!

12.6 테크닉의 복습

# << 연산자의 오버로딩
cout과 함께 사용하여 객체의 내용을 출력할 수 있다.
프렌드 연산자 함수 정의
ostream& operator<<(ostream& os, const c_name& obj)
{
	os << ...;
	return os;
}

# 변환 함수들
어떤 하나의 값을 클래스형으로 변환하려면
c_name(type_name value);
c_name은 클래스 이름 // type_name은 변환하기를 원하는 데이터형의 이름이다.

클래스형을 다른 데이터형으로 변환하려면
operator type_name();
선언된 리턴형이 없지만, 원하는 데이터형의 값을 리턴해야 한다.

변환 함수는 조심해서 사용해야 한다.
암시적 변환이 이루어지지 않게 하려면 생성자를 선언할 때, 키워드 explicit을 사용하자.

# 생성자가 new를 사용하는 클래스

- new에 의해 대입된 메모리를 지시하는 클래스 멤버는, 클래스 파괴자에서 delete 연산자를 그것에 적용해야 한다.
- 파괴자 클래스 멤버인 어떤 포인터에 delete를 적용하여 메모리를 해제한다면, 그 클래스의 모든 생성자들은 new를 사용하거나 그 포인터를 널 포인터로 설정함으로써,
  그 포인터를 초기화해야 한다.

- 생성자들은 new[] 또는 new를 사용할 수 있으나 둘을 섞어서 사용할 수 없다.

- 기존의 메모리를 지시하는 포인터를 복사하지 않고, 새로운 메모리를 대입하는 복사 생성자를 정의해야 한다.
  이 복사 생성자를 사용하여 하나의 객체를 다른 객체로 초기화할 수 있다.
  className(const className&);

- 대입 연산자를 오버로딩하는 클래스 멤버 함수를 정의해야 한다.
c_name& c_name::operator=(const c_name& cn)
{
	if (this == &cn);
		return *this;

	delete[] c_pointer;

	c_pointer = new type_name[size];
	...
	return *this;
}

# 실제 프로그래밍 문제에 적용법
Queue 클래스를 정의

큐가 가져야 할 속성들을 먼저 나열해보면
- 항목들을 도착한 순서대로 보관
- 보관할 수 있는 항목 수에 한계가 존재
- 비어 있는 큐를 생성할 수 있어야 함.
- 비어 있는지 검사
- 가득 차 있는지 검사
- 꼬리 부분에 항목을 추가
- 머리 부분에 항목을 삭제
- 항목 수를 알 수 있어야 함.

클래스를 설계할 때, public 인터페이스와 private 인터페이스 세부 구현을 개발할 필요가 있다.

인터페이스를 결정한 후에는 그것을 세부적으로 구현할 수 있어야 한다.

1. new를 사용하여 필요한 만큼의 원소 수를 가진 배열을 동적으로 대입한다.
큐 연산에 어울리지 않다.
배열의 앞에서 항목을 삭제하면, 나머지 모든 원소들을 한 단위씩 앞으로 옮겨야 한다.
아니면 배열을 원형으로 취급하는 등 보다 정교한 처리가 필요하다.

2. 링크드 리스트를 사용하는 것이 큐가 요구하는 사항에 어울린다.
링크드 리스트는 노드들이 연결되어 구성되는데,
각 노드는 그 노드에 저장되는 정보와 그 다음 노드를 지시하는 하나의 포인터를 가진다.
Struct Node
{
	Item item; // typedef으로 Item 지정해서, 어떤 아이템이든 보관을 변경할 수 있게 한다.
	struct Node* next;
};

# 내포된 구조체와 클래스
구조체, 클래스, 열거체가 어떤 클래스 안에서 선언되면?
그 클래스에 내포된다고 할 수 있다.
이 선언은 그 클래스의 사용 범위를 가지게 된다.

만약에 public 부분에 선언되어 있다면? Queue::Node형 처럼 사용될 수 있다.

# 멤버 초기화 리스트(member initialize list)
Queue::Queue(int qs) : qsize(qs) // qsize를 qs로 초기화
{
}

일반적으로 그 초기값으로는 상수들과, 생성자 매개변수 리스트에 나오는 매개변수를 사용할 수 있다.
상수들을 초기화시키는 것에만 제한되지 않는다.
Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)
{
}

주의할 점은 멤버 초기자 리스트 문법은 생성자만이 사용할 수 있다.
const 데이터와 마찬가지로, 참조는 생성될 때에만 초기화될 수 있다.

초기화는 중괄호 안의 코드가 실행되기 전, 객체가 생성될 때 이루어진다.
- 이 형식은 생성자에만 사용될 수 있다.
- C++11 버전 이전에는 static이 아닌 const 데이터 멤버를 초기화하려면 이 형식을 사용해야 한다.
- 참조 데이터 멤버를 초기화하려면 이 형식을 이용해야 한다.

데이터 멤버들은, 초기자 리스트에 나열된 순서가 아니고, 클래스 선언에 선언된 순서대로 초기화 된다.

참고로
int games = 162;

-> int games(162);
이것은 내장 데이터형의 초기화를 클래스 객체의 초기화처럼 보이게 만드는 것을 허용한다.

# C++11 멤버 In-class 초기화
생성자 내의 멤버 초기화 리스트를 사용하는 것과 동일한 내용이다.
class Classy
{
	int mem1 = 10;       // in-class 초기화
	const int mem2 = 20; // in-class 초기화
}

Classy::Classy() : mem1(10), mem2(20) { ... }

만약 멤버 초기화 리스트를 사용하는 생성자가 호출되지 않았다면,
mem1은 10, mem2는 20으로 초기화 된다.

Classy::Classy(int n) : mem1(n) { ... }
이 경우에는 mem1은 n값을 사용, mem2는 여전히 20으로 된다.
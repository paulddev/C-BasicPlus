Chapter11. 클래스의 활용

클래스의 일반적인 규칙보다는 클래스 설계 테크닉에 더 중점을 두면서 클래스의 특성에 대해 좀 더 알아보자.

실수를 두려워하지 말고, 외워서 정확하게 처리하기 보다는 에러를 해결함으로써 더 많은 것을 배울 수 있다.

# 연산자 오버로딩
C++가 가진 다형 특성의 한 예.

시그니처(매개변수 리스트)를 다르게 제공하면, 이름이 같은 여러 함수를 정의할 수 있다는 것 => 함수 오버로딩 또는 함수 다형이라고 한다.

함수 오버로딩의 목적은 적용할 데이터형이 서로 다르더라도 동일한 함수 이름으로 동일한 연산을 수행하도록 하자는 것

연산자 오버로딩은 그러한 오버로딩 개념을 연산자에까지 확장하여, C++ 연산자들에 다중적인 의미를 부여하는 것이다.

ex)
간단한 덧셈 표기는 내부 계산을 드러내지 않고, 단지 두 객체를 더하고 있다는 사실만 강조하는 느낌처럼 말이다.

operatorop(argument-list)
op는 오버로딩할 연산자를 나타내는 기호다.

# 함수의 매개변수가 참조일 때
매개변수를 참조를 사용하는 이유는 효율성 때문이다.

일반적으로는 간단히 참조를 전달하는 것이 더 빠르고, 메모리 측면에서도 좀 더 효율적이다.
그러나 리턴값은 참조가 될 수 없다!

ex)
Time Time::Sum(const Time& t) const
{
	...
}

Sum() 함수가 두 개의 Time 객체를 더한 결과를 나타내는, 새로운 Time 객체를 만들어내기 때문이다.
객체를 리턴하는 것은 그 함수를 호출한 함수가 사용할 수 있는 복사본 객체를 생성한다.

만약에 리턴형이 Time& 참조라면, 그 참조는 Sum 객체 자신이 된다.
그러나 Sum 객체는 지역 변수이고, 그 함수가 종료될 때 파괴된다.
따라서 그러한 참조는 존재하지 않는 객체에 대한 참조가 되어 버린다.

그래서 Time을 리턴형으로 사용하면, sum 객체를 파괴하기 전에 프로그램이 sum 객체의 복사본을 생성한다.
결과적으로 호출한 함수는 그 복사본을 사용하게 된다.

주의!
지역 변수에 대한 참조 또는 다른 임시 객체에 대한 참조를 리턴하면 안 된다.
함수가 종료되고 지역 변수나 임시 객체가 사라질 때, 그러한 참조는 존재하지 않는 데이터에 대한 참조가 된다.

t1,t2,t3,t4 가 모두 Time 객체일 때
t4 = t1 + t2 + t3; // 가능
t4 = t1.operator+(t2 + t3);
t4 = t1.operator+(t2.operator+(t3));

# 오버로딩 제약
오버로딩된 연산자는, 적어도 하나의 피연산자가 사용자 정의 데이터형일 것을 요구한다.
마찬가지로, 연산자 우선순위도 변경할 수 없다.
마찬가지로, 연산자 기호를 새로 만들 수 없다.

# 프렌드의 도입
C++는 클래스 객체의 private 부분에 접근하는 것을 통제한다.

하지만, C++는 프렌드(friend)라는 또 하나의 접근 통로를 제공한다.
- 프렌드 함수
- 프렌드 클래스
- 프렌드 멤버 함수

함수를 어떤 클래스에 대한 프렌드로 만들면, 그 프렌드 함수는 클래스의 멤버 함수들이 가지는 것과 동등한 접근 권한을 갖게 된다.
위에서 배웠듯이 B * 2.75는 피연산자가 호출한 객체이기 때문에 당연히 연산자 오버로딩으로 인해 가능하지만
2.75 * B는 멤버 함수에 대응시킬 수 없게 되는데,

이럴땐,
A = operator*(2.75, B);
멤버가 아닌 함수 호출로 대응시킬 수 있다.

Time operator*(double m, const Time& t);
멤버가 아닌 오버로딩 연산자 함수를 사용할 때, 연산자 표현식의 왼쪽 피연산자는 그 연산자 함수의 첫 번째 매개변수에 대응하고,
오른쪽 피연산자는 두 번째 매개변수에 대응한다.

# 프렌드 생성하기

프렌드 함수를 만드는 첫 번째 단계는 클래스 선언에 원형을 넣는 것이다.
friend Time operator*(double m, const Time& t);
- 클래스 선언 안에 선언되지만 멤버 함수가 아니므로 멤버 연산자를 사용하여 호출되지 않는다.
- 비록 멤버 함수는 아니지만 멤버 함수와 동등한 접근 권한을 가진다.

두 번째 단계는 함수 정의를 작성하는 것이다.
이때는 멤버 함수가 아니기 때문에 Time:: 제한자를 사용하지 않는다.
또한, 그 정의에 friend 라는 키워드도 사용하지 않는다.

Time operator*(double m, const Time& t)
{
	Time result;
	long totalminutes = t.hours * m * 60 + t.minutes * m;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}

이렇게 선언하고 정의하면,
A = 2.75 * B; 는
아래와 같이 번역되며, 방금 정의한 멤버가 아닌 프렌트 함수를 호출하게 된다.
A = operator*(2.75, B);

=> 어떤 클래스에 대한 프렌드 함수는 멤버 함수와 동등한 접근 권한을 가지는, 멤버가 아닌 함수다.

프렌드 함수들을 클래스를 위한 확장 인터페이스의 일부라고 생각해야 한다.

이렇게도 할 수 있다.
Time operator*(double m, const Time& t)
{
	return t * m; // t.operator*(m)
}

이 버전에서는 굳이 프렌드일 필요는 없으나, 그럼에도 프렌드로 만드는 것이 바람직하다.
가장 중요한 이유는 그 함수가 클래스의 공식 인터페이스의 일부로 결합되는 것이다.

# 프렌드: << 연산자 오버로딩
핵심은 객체의 내용을 출력할 수 있다는 것이다.

cout << trip; // cout이 Time 클래스를 인식하게 만든다.

ostream& operator<<(ostream& os, const Time& t)
{
	os << t.hours << "시간, " << t.minutes << "분";
	return os;
}

리턴형이 ostream&
함수가 ostream 객체에 대한 참조를 리턴한다는 의미

cout << trip;
operator<<(cout, trip);
참조를 리턴함으로써 아래의 구문도 완벽하게 수행한다.
cout << "여행 일시: " << trip << " (화요일)\n";

쪼개보면
cout << "여행 일시: ";
문자열을 출력하고 cout 객체를 리턴한다.

cout << trip << " (화요일)\n";
프로그램은 trip 객체의 값을 출력하고 cout 객체를 다시 리턴한 후
다시 문자열을 출력하게 된다.

클래스 선언에 있는 원형 앞에만 키워드 friend를 사용하고,
정의가 곧 원형인 경우를 제외하고는 함수 정의에는 키워드 friend를 사용하지 않는다.

# 오버로딩 연산자: 멤버 함수와 멤버가 아닌 함수
연산자 오버로딩을 구현할 때, 멤버 함수로 구현할 것인지 멤버가 아닌 함수로 구현할 것인지를 선택해야 한다.
일반적으로는 멤버가 아닌 함수가, 클래스의 private 데이터에 직접 접근할 수 있는 프렌트 함수다.

Time operator+(const Time& t) const; // 멤버 함수

friend Time operator+(const Time& t1, const Time& t2); // 멤버 아닌 함수

멤버 함수 버전은 this 포인터를 통하여 암시적으로 하나가 전달되고, 다른 하나는 함수 매개변수로 명시적으로 전달되고
프렌드 함수 버전은 둘 다 매개변수로 전달된다.

T1 = T2 + T3
T1 = T2.operator+(T3); // 멤버 함수
T1 = operator+(T2, T3); // 멤버가 아닌 함수

주어진 하나의 연산자를 정의할 때, 사용자는 두 형식 중 반드시 어느 한 형식을 선택해야 하는데
두 형식이 동일한 표현식에 해당하므로, 두 형식을 모두 정의하는 것은 컴파일 에러를 일으키는 모호성 에러로 간주된다.
=> 일부 연산자들에 대해서는 멤버 함수가 유일하고도 적절한 선택이다.
간혹 멤버가 아닌 버전이 유리할 수 있는데, 이는 변환과 프렌드에서 확인해보자.

# operator<<()는 프렌드 기능이지 클래스 범위의 일부가 아니기 때문에, enum을 사용할 때
RECT 대신에 VECTOR::RECT로 사용해야 한다.

# 팁!
메서드가 새로운 클래스 객체를 만들어 계산할 필요가 있을 경우에는
클래스 생성자를 사용하여 그 일을 처리할 수 있는지 살펴보자.
클래스 생성자로 처리하면, 전혀 문제를 일으키지 않을 뿐만 아니라 올바른 방식으로 새로운 객체를 생성할 수 있기 때문이다.

# 한걸음더
C++에서 -연산자는 2가지 의미가 있다.
1. 두 개의 피연산자에 사용되었을 때에는 뺄셈 연산자로 사용된다.
-> 두 개의 피연산자를 요구하므로 이항 연산자(binary operator)라고 부른다.

2. 마이너스 부호 연산자 (반전)
-> 피연산자를 한 개만 요구하므로 단항 연산자(unary operator)라고 부른다.

핵심은 구현과 인터페이스를 분리하는 것이 OOP의 목표 중 하나다.
클래스를 사용하는 프로그램의 코드는 변경하지 않고, 세부 구현을 미세하게 조정하는 것이 가능하다.

# 데이터 룩업(lookUp)
미리 계산해놓은 값들을 저장한 컨테이너 혹은 테이블을 말한다.
예를 들면, C++에서 코사인 함수의 값을 미리 계산된 값을 배열에 저장해놓고 사용하는 것.

# 자동 변환과 클래스의 데이터형 변환
C++는 그 값의 데이터형을 대입받는 입장에 있는 변수와 동일한 데이터형으로 자동으로 변환해준다.

long count = 8;   // int -> long
double time = 11; // int -> double
int side = 3.33;  // double -> int 잘려서 3만 저장

다만, C++는 호환되지 않는 데이터형은 자동으로 변환하지 않는다.

Stonewt myCat;
myCat = 19.6; // Stonewt(double)을 사용하여 19.6을 Stonewt로 변환한다. (암시적 데이터형 변환!)

C++를 많이 경험하게 되면, 자동 데이터형 변환이 항상 바람직한 것은 아니다.
오히려 예상하지 못한 부작용을 일으킬 수 있다는 점.

자동 데이터형 변환을 못하게 하는 explicit 키워드가 존재한다.
암시적 데이터형 변환을 허용하지 못하게 한다.

myCat = Stonewt(19.6); // 명시적 데이터형 변환
myCat = (Stonewt) 19.6; // 명시적 데이터형 변환(옛날 형식)

암시적 데이터형 변환이 사용되는 구간
- Stonewt 객체를 double형 값으로 초기화할 떄
- Stonewt 객체에 double형 값을 대입할 때
- Stonewt형 매개변수를 기대하는 함수에 double형 값을 전달할 때
- Stonewt형 값을 리턴하도록 선언된 함수가 double형 값을 리턴하려고 할 때

주의할 점
Stonewt(double) 생성자만 구현한게 아니라,
Stonewt(long) 생성자도 구현했다면?

Stonewt Jumbo(7000); 은 어떤 걸 호출해야할 지 모호해진다.

C++에서는 int형과 double형 값을 둘 다 long형 변수에 대입할 수 있다.

# 변환 함수
생성자는 어떤 데이터형을 클래스형으로 변환하는 것만 허용한다.
이 과정을 반대로 하는 것이 변환 함수!

Stonewt wolfe(275.7);
double host = double(wolfe);    // 명시적
double thinker = (double)wolfe; // 명시적
double star = wolfe; // 변환 함수를 암시적으로 사용하는 방법 (컴파일러가 스스로 처리)

operator typeName(); 으로 작성하면 된다.

변환 함수는 클래스의 메서드여야 한다.
변환 함수는 리턴형을 가지면 안 된다.
변환 함수는 매개변수를 가지면 안 된다.
ex)
operator double();
-> 어떤 데이터형으로 변환할 것인지 알려준다. (그래서 리턴형이 필요없음)
특정 클래스 객체에 의해 호출되어야 한다! (그래서 매개변수도 필요없음)

operator int();
operator double();

C++11에서는 사용자가 변환 연산자를 explicit로 선언할 수 있게 된다.

* 암시적 변환 함수는 신중하게 사용해야 한다.
명시적으로만 호출할 수 있는 함수를 사용하는 것이 바람직하다.

<정리>
하나의 매개변수를 사용하는 클래스 생성자는, 그 매개변수의 데이터형을 클래스형으로 변환하는 명령어 역할을 한다.

변환 함수라고 부르는 클래스 멤버 연산자 함수는, 클래스 객체를 다른 어떤 데이터형으로 변환하는 명령어 역할을 한다.

멤버 함수는 클래스 객체만이 호출할 수 있다...

=> 다양한 경험이 필요하다. (암시적보다는 명시적!)
=> C++는 클래스형으로 또는 클래스형에서 다른 데이터형으로 변환하는 것을 허용한다.
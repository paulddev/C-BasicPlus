Chapter10. 객체와 클래스

# OOP 중요 개념들
- 추상화(abstraction)
- 캡슐화(encapsulation), 데이터 은닉(data hiding)
- 다형성(polymorphism)
- 상속(inheritance)
- 코드의 재활용(reusability of code)

C++의 클래스
추상화를 사용자 정의 데이터형으로 변환해주는 C++ 수단
데이터 표현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.

인터페이스
두 시스템 간의 상호 작용을 위한 공통된 프레임워크.
우리는 프로그램이 제공하는 인터페이스와 상호 작용한다.
프로그램 인터페이스는 사용자의 의도를 컴퓨터에 저장되어 있는 특정 정보를 변환하는 것을 담당한다.

# 접근 제어
public 멤버 함수는 객체와 프로그램 사이의 인터페이스를 제공한다.
프로그램이 데이터에 직접 접근하지 못하게 차단하는 것을 데이터 은닉(data hiding)이라고 한다.

클래스 설계는 public 인터페이스와 세부적인 구현을 분리하려고 노력한다.
세부적인 구현들을 따로 결합하여 추상화와 분리하는 것을 캡슐화(encapsulation)라고 한다.

데이터 은닉은 데이터에 직접 접근하지 못하게 막아 줄 뿐만 아니라, 데이터 표현이 어떻게 되어 있는지에 대해
클래스 사용자가 신경 쓰지 않도록 해준다.

멤버 함수가 요구하는 매개변수의 종류와 그것이 리턴하는 값의 종류만 알면 된다.
C++에서는 클래스 객체에 대한 디폴트 접근 제어는 private.

public 부분에 있는 내용은 설계의 추상화 부분인 public 인터페이스가 된다.
private 부분에 데이터를 넣어 캡슐화하는 것은 데이터의 무결성을 보호하기 위한 것으로, 데이터 은닉이라고 한다.

클래스의 사용은 추상화, 데이터 은닉, 캡슐화라는 OOP의 목표를 쉽게 구현할 수 있게 해 주는 C++ 방법이다.

# 클래스와 구조체
유일한 차이는 구조체는 디폴트 제어 접근이 public이고 클래스는 디폴트 제어 접근이 private
C++ 프로그래머들은 클래스를 일반적으로 클래스 서술을 하는 데 사용하고,
순수한 데이터 객체를 정의하는 데에는 구조체를 사용한다.

# 클래스 멤버 함수의 구현
클래스 선언에서 원형으로 나타낸 멤버 함수들에 대한 코드를 제공해야 한다.
- 멤버 함수를 정의할 때, 그 멤버 함수가 어느 클래스에 속하는지를 나타내기 위해 사용자 범위 결정 연산자(::)를 사용해야 한다.
- 클래스 메서드는 그 클래스의 private 부분에서만 접근할 수 있다.

메서드가 가지고 있는 특별한 특징은, 메서드가 클래스의 private 멤버들에 접근할 수 있다는 점이다.
메서드 정의는 클래스 선언과 같은 파일에 또는 독립된 파일에 넣을 수 있다.
(보통 간단하게 시작하고 있어서 메서드 정의들이 클래스 선언과 같은 파일에 들어 있다.)
최상의 방법은 클래스 선언을 헤더 파일에 넣고, 클래스 멤버 함수 정의들을 독립된 소스 코드 파일에 넣는 것이다.

클래스 선언에 함수 원형 대신에 완전한 함수 정의를 넣을 수도 있는데,
일반적으로는 매우 짧은 함수들은 제외하고, 함수 정의들을 따로 분리하여 제공한다.

# 인라인 메서드
클래스 선언 안에 정의를 가지고 있는 모든 함수는 자동으로 인라인 함수가 된다.
클래스 선언은 짧은 멤버 함수들에 대해서 인라인 함수를 사용하는 경우가 많다.

원한다면 클래스 선언의 외부에 멤버 함수를 정의하고, 그것을 인라인 함수로 만들 수 있다.
그때는 inline 제한자를 붙이자.
inline void Stock::set_tot() {}

인라인 함수들은 그들이 사용되는 각각의 파일에서 정의될 것을 요구한다.
해당 클래스가 정의되어 있는 헤더 파일에 인라인 정의를 함께 넣는다.

# 어느 객체가 메서드를 사용할까?
생성된 각 객체는 자체의 내부적인 변수들(클래스 멤버들)을 위한 저장 공간을 가진다.
같은 클래스에 속하는 모든 객체들은, 클래스 메서드들이 한 카피씩 모여서 구성된 동일한 클래스 메서드 집합을 공유한다!
=> 한 마디로 동일한 메서드를 호출한다는 뜻
멤버 함수를 호출한다는 말은, 다른 OOP 언어에서 메시지를 보낸다는 말과 같다.
두 개의 서로 다른 객체에 같은 메시지를 보낸다는 말은, 같은 메서드를 호출하여 그것을 두 개의 서로 다른 객체에 적용한다는 말과 같은 것이다.

# 클라이언트-서버 모델
클라이언트는 클래스를 사용하는 프로그램이다.
클래스 메서드를 포함하여, 클래스 선언이 서버를 구성한다.
서버는 그것을 필요로 하는 프로그램들이 사용할 수 있는 리소스다.

클라이언트는 public 으로 정의된 인터페이스를 통해서만 서버를 사용한다.
클라이언트의 유일한 책임이 그 인터페이스를 이해하는 것을 의미한다.
서버 책임은 그 서버가 그 인터페이스에 따라 신뢰성 있고 정확하게 수행되는지 확인하는 것이다.

서버 설계자가 그 클래스 설계에 가하는 모든 변경은 인터페이스가 아니라 세부 구현이어야 한다.
클라이언트의 행동에 예측할 수 없는 영향을 일으키는 변화를 서버에 가져오지 않고,
클라이언트와 서버의 기능을 프로그래머들이 서로 독립적으로 개선하는 것을 허용한다.

# 클래스 생성자와 파괴자
생성자(Constructor), 파괴자(Destructor)

클래스 생성자
- 객체가 생성될 때 자동으로 초기화되게 만드는 것
생성자는 리턴값이 없는데도 불구하고 void형으로 선언하지 않는다.
생성자에는 데이터형을 선언하지 않는다.

생성자 사용하기
- 1. 명시적으로 호출
- 2. 암시적으로 호출
C++는 해당 클래스의 객체를 생성할 때마다 클래스 생성자를 사용한다.
동적 메모리 대입을 위해 new를 사용할 때에도 마찬가지다.

Stock* pstock = new Stock("Electrosshock", 50, 19.0);

생성자가 객체를 만드는 일을 끝내기 전까지는 객체가 없는 상태이므로, 생성자 호출에 객체를 사용할 수 없다.
생성자는 객체에 의해 호출되는 것이 아니라, 객체를 생성하는 데 사용된다.

# 디폴트 생성자 (Default Constructor)
명시적인 초기화 값을 제공하지 않을 때, 객체를 생성하는 데 사용하는 생성자다.
사용자가 생성자를 제공하지 않아도 C++는 자동으로 디폴트 생성자를 제공하기 때문이다.
디폴트 생성자는 아무런 일도 하지 않는다.

중요한 건, 사용자가 어떠한 생성자도 정의하지 않을 때에만 컴파일러가 디폴트 생성자를 제공한다.

사용자는 하나의 디폴트 생성자만 가질 수 있다.
일반적으로는 사용자가 객체를 초기화해 주어야 한다.
그러므로, 대개 디폴트 생성자는 모든 멤버들의 값에 암시적인 초기화를 제공한다.

Stock first;                // 디폴트 생성자를 암시적으로 호출
Stock first = new Stock();  // 디폴트 생성자를 명시적으로 호출
Stock *prelief = new Stock; // 디폴트 생성자를 암시적으로 호출

허나
Stock first("Concreate Conglo"); // 생성자를 호출한다.
Stock second(); // 함수를 선언한다.
Stock third;    // 디폴트 생성자를 암시적으로 호출한다.
=> 디폴트 생성자를 암시적으로 호출할 때에는 괄호를 사용하면 안 된다.

파괴자
프로그램은 객체의 수명이 다할 때까지 그 객체를 추적하는 책임을 맡는다.
객체의 수명이 끝나는 시점에서, 프로그램은 파괴자라는 특별한 멤버 함수를 자동으로 호출하게 된다.

생성자가 new를 사용하여 메모리를 대입했다면, 파괴자는 delete를 사용하여 대입된 메모리를 해제해야 한다.

정적 기억 공간의 클래스 객체를 생성한다면, 프로그램이 종료될 때 파괴자가 자동으로 호출된다.
자동 기억 공간의 클래스 객체를 생성한다면, 정의된 코드 블록을 프로그램이 벗어날 때 파괴자가 자동으로 호출된다.
new를 사용하여 객체를 생성한다면, 그 객체는 힙 메모리 또는 자유 기억 공간에 저장되므로
그것의 메모리를 해제하기 위해 delete를 사용할 때 파괴자가 자동으로 호출된다.

프로그램이 어떤 작업들을 수행하기 위해 임시적인 객체를 생성할 수 있는데,
그러한 경우에는 프로그램은 그 객체의 사용을 마쳤을 때 파괴자를 자동으로 호출한다.

클래스 객체의 수명이 다했을 때 파괴자는 자동으로 호출되는 것이기 때문에, 반드시 파괴자가 있어야 한다.
사용자가 파괴자를 제공하지 않으면, 컴파일러는 디폴트 파괴자를 선언한다.

# 헤더파일 관련해서
파일명을 <>로 묶지 않고, 큰따옴표로 묶으면?
컴파일러는 그 파일을 소스 파일들이 있는 곳에서 찾는다.

# 임시 객체!!!
생성자에 대한 호출이 임시 객체를 먼저 생성하고,
그 임시 객체가 stock에 복사되는 것인데, 그러고 나서는 임시 객체는 버려지게 된다. (파괴자 호출)
stock = Stock("Nifity Foods", 10, 50.0); // 임시 객체 생성하고, 복사되고, 파괴는 다음 라인에

# 객체 대입
클래스 객체 대입은 기본적으로 한 객체의 멤버들을 다른 객체에 복사하는 것인데
C++ 소스 객체 데이터 멤버들의 각 내용을 타깃 객체의 해당하는 데이터 멤버에 복사한다.

자동 기억 변수들은 스택에 놓이기 때문에, 마지막에 생성된 객체가 먼저 삭제되고, 처음에 생성한 객체가 마지막으로 삭제된다!

객체의 값을 초기화로도 설정할 수 있고, 대입으로도 설정할 수 있다면?
초기화를 사용하자. 일반적으로 그것이 더 효율적이다.

# C++의 리스트 초기화
C++11에서 클래스를 리스트 초기화 구문에 사용이 가능하다.
C++에서는 중괄호 안의 값들과 생성자의 매개변수들을 매칭시키는 것을 제공한다.
Stock hot = {"Derivatives", 100, 45.0};
Stock jock = {"Sport"};
는
Stock::Stock(const std::string& co, long n = 0, double pr = 0.0);
에 매칭된다.

Stock temp {};
는
기본 생정자에 매칭된다.

추가로 C++11에서는 std::initializer_list 클래스를 호출할 수 있다.

# const 멤버 함수
const Stock land = Stock("Ludk");
land.show();

const이기 때문에 변경하면 안 되는 호출 객체를 show()에 해당하는 코드가 수정하지 않는다는 보장을 하지 않기 때문에
함수의 매개변수를 const 참조나 const를 지시하는 포인터로 선언함으로써 이런 문제를 해결하였는데,
show() 메서드는 매개변수를 갖지 않는다.

void show() const; // 호출 객체를 변경하지 않는다고 약속한다.
void Stock::show() const {}

이 방식으로 선언되고 정의된 클래스 함수들은 const 멤버 함수라고 한다.

# 생성자와 파괴자에 대한 요약

Bozo bozetta = Bozo("Bozetta", "Biggers"); // 기본 형식
Bozo fufu("Fufu", "Dweeb");                // 짧은 형식
Bozo* pc = new Bozo("Popo", "Le peu");     // 동적 객체

C++11 라면?
Bozo bozetta = Bozo{"Bozetta", "Biggers"};
Bozo fufu{"Fufu", "Dweeb"};
Bozo* pc = new Bozo{"Popo", "Le peu"};

만약에 생성자가 한 개의 매개변수만 가진다면?
Bozo bubby = 12; // 매개 변수가 하나인 생성자를 위한 특별 형식이 존재한다.

디폴트 생성자는 매개변수가 없으며, 명시적으로 초기화하지 않고 객체를 생성할 때 사용한다.

객체가 파괴될 때 프로그램은 파괴자를 호출한다.
파괴자는 클래스당 하나만 가질 수 있다.

클래스 파괴자는 클래스 생성자가 new를 사용할 때 필요하게 된다.

# this 포인터
this 포인터는 멤버 함수를 호출하는 데 사용된 객체를 지시한다.
(기본적으로 this는 그 메서드에 숨은 매개변수로 전달된다.)

생성자와 파괴자를 포함한 각각의 멤버 함수는 하나의 this 포인터를 가진다.
this 포인터의 특별한 특징은 호출한 객체를 지시하는 것이다.
만약 const로 제한을 걸어두었다면 this 포인터를 사용하여 그 객체의 값을 변경할 수 없다.

# 객체 배열
Stock mystuff[4];

명시적으로 초기화되지 않은 클래스 객체들을 생성할 때, 프로그램은 항상 디폴트 클래스 생성자를 호출한다.

대부분의 노력이 클래스를 설계하는 데 들어가고, 클래스를 정의하면 프로그램을 작성하는 일은 매우 간단해진다.

# C++ 포인터에서 const 위치에 따른 차이점

int value = 42;
const int* p = &value;

p = &value; // ok
*p = 20;    // no

int* const p = &value;

p = &value; // no
*p = 20;    // ok

# 클래스 사용 범위
전역 사용 범위: 그 정의가 들어 있는 파일의 어디에서나 사용할 수 있다.
지역 사용 범위: 블록 사용 범위를 가지는 변수는 그 정의가 들어 있는 블록으로 사용 범위가 제한된다.

함수 이름도 전역 사용 범위를 가질 수 있다. 그러나 지역 사용 범위는 가질 수 없다.
C++ 클래스는 클래스 사용 범위라는 새로운 종류의 사용 범위를 도입한다.

클래스 사용 범위를 갖는 것들은 클래스 안에는 알려지지만 클래스 바깥에는 알려지지 않는다.


# 클래스 사용 범위 상수
클래스를 선언하는 것은 객체가 어떻게 생겼는지 서술하는 것이지, 그 객체를 생성하는 것은 아니다.

클래스 안에 열거체를 선언할 수 있다.
클래스 선언 안에 주어지는 열거체는 클래스 사용 범위를 갖게 된다.
컴파일할 때 클래스 사용 범위에 들어 있는 코드에서 기호 이름이 Len이 발견되면, 컴파일러는 그것을 단순히 30으로 대체할 뿐이다.

열거체는 열거체 변수를 생성하기 위한 것이 아니라 단순히 기호 상수를 생성하기 위한 것이다.

최근에는 C++에서 키워드 static을 사용하여 클래스 안에 상수를 정의하는 제 2의 방법이 있다.

class Bakery
{
private:
	static const int Months = 12;
	double costs[Months];
};

이것은 객체 안이 아니라 다른 정적 변수들과 함께 저장되는 Months라는 하나의 상수를 생성한다.
그래서 모든 Bakery 객체들이 하나의 Months 상수를 공유한다!

# 범위가 정해진 열거(C++11)
enum egg {Small, Medium, Large, Jumbo};
enum t_shirt {Small, Medium, Large, Jumbo};
=> 모두 동일한 범위에 있어서 서로 충돌이 발생

enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Jumbo};
클래스 대신에 struct 키워드도 가능하다.

=> 열거자는 클래스 범위를 지니고 있기 때문에 더 이상 이름이 충돌할 가능성이 없다.

# 추상화 데이터형
프로그래머들은 좀 더 일반적인 개념을 표현하기 위해 클래스를 정의한다.

클래스를 사용하는 것은 컴퓨터 과학자들이 추상화 데이터형(abstract data type, ADT)라고 부르는 것을 구현할 수 있는 좋은 방법이다.

스택의 특성을 일반적이고 추상적인 방식으로 보면,

- 빈 스택을 생성
- 스택의 꼭대기에 항목을 추가
- 스택의 꼭대기에 항목을 삭제
- 스택이 가득 차 있는지 검사
- 스택이 비어 있는지 검사

public 멤버 함수들로 스택 연산을 나타내는 인터페이스를 제공하는 클래스 선언과 이 서술을 대응시킬 수 있다.
스택 데이터의 저장은 private 데이터 멤버들이 담당한다.

private 부분은 데이터 저장 방법을 정해야 하는데,
일반 배열, 동적 대입 배열, 링크드 리스트, 좀 더 높은 수준의 데이터 구조를 사용할 수 도 있다.

그러나 public 인터페이스는 그러한 정확한 표현이 드러나지 않게 해야 한다.
대신에 스택을 생성하고, 항목을 푸시한다는 등의 일반적인 용어로 표현해야 한다.

# 요약 정리!
OOP는 프로그램이 데이터를 표현하는 방법을 강조한다.
데이터를 프로그램의 인터페이스를 가지고 서술하는 것
인터페이스는 데이터를 사용하는 방법을 말한다.

인터페이스를 구현하는 클래스를 설계한다.
private 데이터 멤버들이 정보를 저장하고, 메서드라 부르는 public 멤버 함수들이 유일한 데이터 접근 방법을 제공한다.

클래스 선언을 두 부분으로 나누어, 각 부분을 독립된 파일에 저장한다.
메서드들이 원형으로 표현되어 있는 클래스 선언을 하나의 헤더 파일에 저장
그 멤버 함수들을 정의하는 소스 코드는 다른 하나의 메서드 파일에 저장
=> 인터페이스와 세부 구현을 분리시키는 것

클래스는 사용자 정의 데이터형이다.
객체는 클래스의 구체적인 하나의 사례(instance)이다.

객체들은 클래스 선언의 데이터 부분에 대한 사본을 하나씩 갖지만, 클래스 메서드들은 공유한다!

*this는 그 객체 자체의 대용 이름이다.
